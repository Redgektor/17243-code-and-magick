{"version":3,"sources":["webpack:///webpack/bootstrap a662ec1305bfa14c9903","webpack:///./src/main.js","webpack:///./src/check.js","webpack:///./src/form.js","webpack:///./~/browser-cookies/src/browser-cookies.js","webpack:///./src/game.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;ACtCA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,eAAc,WAAW;AACzB;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA,EAAC;;;;;;;AC1BD;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAG;AACH;;AAEA,IAAG;AACH;AACA;AACA,MAAK;AACL;;AAEA,IAAG;AACH;AACA;AACA,MAAK;AACL;AACA;AACA;;;;;;;ACxBA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,kBAAiB,mBAAmB;AACpC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,cAAa,OAAO;AACpB,eAAc,OAAO;AACrB,gBAAe;AACf;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,2BAA0B;;AAE1B;AACA;AACA;;AAEA;AACA;;AAEA;AACA,gBAAe,SAAS;AACxB;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA,EAAC;;;;;;;AC3KD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,wCAAuC;AACvC,0CAAyC;AACzC,iBAAgB;AAChB,iBAAgB;AAChB,iBAAgB;AAChB,iBAAgB,wBAAwB;AACxC;;AAEA;AACA,yCAAwC;;AAExC;AACA,iBAAgB,oBAAoB;AACpC;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AClEA;;AAEA;AACA;AACA;AACA,aAAY;AACZ;AACA;;AAEA;AACA;AACA,aAAY;AACZ;AACA;;AAEA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAY;AACZ;AACA;;AAEA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA,cAAa,OAAO;AACpB,eAAc;AACd;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;;AAEA;AACA;AACA,aAAY;AACZ;AACA;;AAEA;AACA;AACA,cAAa,OAAO;AACpB,eAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,cAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,eAAc;AACd;AACA;;AAEA,iBAAgB,QAAQ;AACxB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,QAAO;AACP;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,iBAAgB;AAChB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;;AAET;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,gBAAe,OAAO;AACtB,gBAAe,SAAS;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,QAAO;AACP,MAAK;;AAEL;AACA;AACA,gBAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA,gBAAe,eAAe;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,MAAK;AACL;AACA;AACA,gBAAe,SAAS;AACxB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,uBAAsB;AACtB,sBAAqB;;AAErB,wBAAuB;;AAEvB;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,kBAAiB,OAAO;AACxB,kBAAiB,OAAO;AACxB,kBAAiB,OAAO;AACxB,kBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,kBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,kBAAiB,OAAO;AACxB,kBAAiB,OAAO;AACxB,oBAAmB;AACnB;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,UAAS;;AAET;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,gBAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAO;;AAEP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,gBAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA,QAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;;AAET;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,QAAO;;AAEP;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAkB;AAClB;AACA;AACA;AACA;AACA,sBAAqB,OAAO;AAC5B,uBAAsB;AACtB;AACA;AACA;AACA;AACA,cAAa;;AAEb;AACA;AACA;AACA,YAAW;;AAEX;AACA;AACA,sBAAqB,OAAO;AAC5B,uBAAsB;AACtB;AACA;AACA;AACA,YAAW;;AAEX;AACA;AACA,sBAAqB,OAAO;AAC5B,uBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,gBAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA,gBAAe,cAAc;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;;AAEL;AACA,gBAAe,cAAc;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,EAAC","file":"main.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap a662ec1305bfa14c9903\n **/","'use strict';\n\nrequire('./check');\nrequire('./form');\nrequire('./game');\n\n(function() {\n  var game = new window.Game(document.querySelector('.demo'));\n  game.initializeLevelAndStart();\n  game.setGameStatus(window.Game.Verdict.INTRO);\n\n  var formOpenButton = document.querySelector('.reviews-controls-new');\n\n  /** @param {MouseEvent} evt */\n  formOpenButton.onclick = function(evt) {\n    evt.preventDefault();\n\n    window.form.open(function() {\n      game.setGameStatus(window.Game.Verdict.PAUSE);\n      game.setDeactivated(true);\n    });\n  };\n\n  window.form.onClose = function() {\n    game.setDeactivated(false);\n  };\n})();\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/main.js\n ** module id = 0\n ** module chunks = 0\n **/","\"use strict\";\n\nfunction getMessage(a, b) {\n  var typeOfA = typeof a;\n  var typeOfB = typeof b;\n  var isArrayA = Array.isArray(a);\n  if (typeOfA === \"boolean\") {\n    return a ? \"Я попал в\" + \" \" + b : \"Я никуда не попал\";\n\n  } else if (typeOfA === \"number\") {\n    return \"Я прыгнул на\" + \" \" + a * 100 + \" \" + \"сантиметров\";\n\n  } else if (isArrayA && typeOfB === \"undefined\") {\n    var stepsCount = a.reduce(function (sum, el) {\n      return sum + el;\n    }, 0);\n    return \"Я прошёл\" + \" \" + stepsCount + \" \" + \"шагов\";\n\n  } else if (isArrayA && Array.isArray(b)) {\n    var metersCount = a.reduce(function (sum, current, i) {\n      return sum + (current * b[i]);\n    }, 0);\n    return \"Я прошёл\" + \" \" + metersCount + \" \" + \"метров\";\n  }\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/check.js\n ** module id = 1\n ** module chunks = 0\n **/","'use strict';\n\nvar browserCookies = require('browser-cookies');\n\nwindow.form = (function() {\n  var formContainer = document.querySelector('.overlay-container');\n  var formCloseButton = document.querySelector('.review-form-close');\n\n  /**\n   * блок с перемеными для работы с формой review-form\n   */\n  var reviewForm = document.querySelector('.review-form');\n\n  var rating = reviewForm.elements['review-mark'];\n\n  var nameField = reviewForm.elements['review-name'];\n  var feedbackField = reviewForm.elements['review-text'];\n\n  var hintsContainer = reviewForm.querySelector('.review-fields');\n  var hintName = hintsContainer.querySelector('.review-fields-name');\n  var hintFeedback = hintsContainer.querySelector('.review-fields-text');\n\n  var submitBtn = reviewForm.querySelector('.review-submit');\n\n  /**\n   * начальные значения формы review-form\n   */\n  nameField.required = true;\n\n  function validateForm() {\n\n    /**\n     * делаем поле отзыва обязательным в зависимости от\n     * выставленной оценки\n     */\n    // true только, если рейтинг ниже 3\n    feedbackField.required = rating.value < 3;\n\n    /**\n     * создаем переменные isNameValid и isFeedbackValid, равные true,\n     * если соответствующие поля заполнены, и false, если не заполнены\n     */\n    var isNameValid = nameField.value;\n\n    var isFeedbackValid = !feedbackField.required || feedbackField.value;\n\n    /**\n     * убираем подсказку в блоке hintsContainer (или блок целиком) в зависимости от\n     * соответствия условию:\n     * добавляем класс 'invisible', когда поле будет заполнено, вне зависимости от рейтинга\n     * ( это поле обязательно для заполнения всегда)\n     */\n    hintName.classList.toggle('invisible', isNameValid);\n\n    /**\n     * добавляем класс 'invisible' только в том случае, если поле перестанет быть обязательным\n     * для заполнения, или уже заполнено\n     */\n    hintFeedback.classList.toggle('invisible', isFeedbackValid);\n\n    /**\n     * добавляем класс 'invisible', если:\n     * поле имени заполено, а поле отзыва заполнять не обязательно, или\n     * заполнены оба поля (имени и отзыва), и поле отзыва обязательно для заполнения\n     */\n    hintsContainer.classList.toggle('invisible', isNameValid && isFeedbackValid);\n\n    /**\n     * добавляем атрибут 'disabled', если:\n     * поле имени не заполено (при этом поле отзыва не обязательно для заполнения), или\n     * не заполнены оба поля (имени и отзыва), при этом поле отзыва обязательно для заполнения\n     */\n    submitBtn.disabled = !(isNameValid && isFeedbackValid);\n  }\n\n  validateForm();\n\n  nameField.addEventListener('input', validateForm);\n\n  feedbackField.addEventListener('input', validateForm);\n\n  for (var i = 0; i < rating.length; i++) {\n    rating[i].addEventListener('change', validateForm);\n  }\n\n  /**\n   * Cookies\n   */\n\n  /**\n   * функция, возвращающая кол-во дней, прошедших с указанной даты\n   * @param {Number} month месяц, от 0 до 11\n   * @param  {Number} date дата, от 1 до 31\n   * @returns {Number}\n   */\n  function getExpiresDate(month, date) {\n\n    var currentDate = new Date();\n\n    /**\n     * получаю компоненты даты\n     * для создания текущей даты с часами / секундами, равными 0:\n     * таким образом последующие вычисления не будут содержать дробные величины\n     */\n    var currentYear = currentDate.getFullYear();\n    var currentMonth = currentDate.getMonth();\n    var currentDay = currentDate.getDate();\n\n    var today = new Date(currentYear, currentMonth, currentDay);\n    var randomDate = new Date(currentYear, month, date);\n    /**\n     * кол-во мс в сутках\n     */\n    var DAY_IN_MS = 3600 * 24 * 1000;\n\n    /**\n     * вычисляем, сколько дней в текущем году (год может быть високосным)\n     */\n    var currentYearDaysNumber = ( new Date(currentYear, 11, 31) - new Date(currentYear, 0, 0) ) / DAY_IN_MS;\n\n    /**\n     * вычисляем кол-во дней, прошедших с момента указанной даты,\n     * с последующей передачей вычисленного значения в функцию\n     * в качестве параметра\n     */\n    var daysDiff = (today - randomDate) / DAY_IN_MS;\n\n    return (daysDiff > 0) ? daysDiff : currentYearDaysNumber + daysDiff;\n  }\n\n  /**\n   * сохраняем выбранные значения в cookies\n   */\n  rating.value = browserCookies.get('review-mark') || rating.value;\n\n  nameField.value = browserCookies.get('review-name') || nameField.value;\n\n  reviewForm.onsubmit = function() {\n    var daysNumExpires = {expires: getExpiresDate(11, 9)};\n\n    browserCookies.set('review-mark', rating.value, daysNumExpires);\n    browserCookies.set('review-name', nameField.value, daysNumExpires);\n  };\n\n  var form = {\n    onClose: null,\n\n    /**\n     * @param {Function} cb\n     */\n    open: function(cb) {\n      formContainer.classList.remove('invisible');\n      cb();\n    },\n\n    close: function() {\n      formContainer.classList.add('invisible');\n\n      if (typeof this.onClose === 'function') {\n        this.onClose();\n      }\n    }\n  };\n\n\n  formCloseButton.onclick = function(evt) {\n    evt.preventDefault();\n    form.close();\n  };\n\n  return form;\n})();\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/form.js\n ** module id = 2\n ** module chunks = 0\n **/","exports.defaults = {};\n\nexports.set = function(name, value, options) {\n  // Retrieve options and defaults\n  var opts = options || {};\n  var defaults = exports.defaults;\n\n  // Apply default value for unspecified options\n  var expires  = opts.expires || defaults.expires;\n  var domain   = opts.domain  || defaults.domain;\n  var path     = opts.path     != undefined ? opts.path     : (defaults.path != undefined ? defaults.path : '/');\n  var secure   = opts.secure   != undefined ? opts.secure   : defaults.secure;\n  var httponly = opts.httponly != undefined ? opts.httponly : defaults.httponly;\n\n  // Determine cookie expiration date\n  // If succesful the result will be a valid Date, otherwise it will be an invalid Date or false(ish)\n  var expDate = expires ? new Date(\n      // in case expires is an integer, it should specify the number of days till the cookie expires\n      typeof expires == 'number' ? new Date().getTime() + (expires * 864e5) :\n      // else expires should be either a Date object or in a format recognized by Date.parse()\n      expires\n  ) : '';\n\n  // Set cookie\n  document.cookie = name.replace(/[^+#$&^`|]/g, encodeURIComponent)                // Encode cookie name\n  .replace('(', '%28')\n  .replace(')', '%29') +\n  '=' + value.replace(/[^+#$&/:<-\\[\\]-}]/g, encodeURIComponent) +                  // Encode cookie value (RFC6265)\n  (expDate && expDate.getTime() >= 0 ? ';expires=' + expDate.toUTCString() : '') + // Add expiration date\n  (domain   ? ';domain=' + domain : '') +                                          // Add domain\n  (path     ? ';path='   + path   : '') +                                          // Add path\n  (secure   ? ';secure'           : '') +                                          // Add secure option\n  (httponly ? ';httponly'         : '');                                           // Add httponly option\n};\n\nexports.get = function(name) {\n  var cookies = document.cookie.split(';');\n\n  // Iterate all cookies\n  for(var i = 0; i < cookies.length; i++) {\n    var cookie = cookies[i];\n    var cookieLength = cookie.length;\n\n    // Determine separator index (\"name=value\")\n    var separatorIndex = cookie.indexOf('=');\n\n    // IE<11 emits the equal sign when the cookie value is empty\n    separatorIndex = separatorIndex < 0 ? cookieLength : separatorIndex;\n\n    // Decode the cookie name and remove any leading/trailing spaces, then compare to the requested cookie name\n    if (decodeURIComponent(cookie.substring(0, separatorIndex).replace(/^\\s+|\\s+$/g, '')) == name) {\n      return decodeURIComponent(cookie.substring(separatorIndex + 1, cookieLength));\n    }\n  }\n\n  return null;\n};\n\nexports.erase = function(name, options) {\n  exports.set(name, '', {\n    expires:  -1,\n    domain:   options && options.domain,\n    path:     options && options.path,\n    secure:   0,\n    httponly: 0}\n  );\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/browser-cookies/src/browser-cookies.js\n ** module id = 3\n ** module chunks = 0\n **/","'use strict';\n\nwindow.Game = (function() {\n  /**\n   * @const\n   * @type {number}\n   */\n  var HEIGHT = 300;\n\n  /**\n   * @const\n   * @type {number}\n   */\n  var WIDTH = 700;\n\n  /**\n   * ID уровней.\n   * @enum {number}\n   */\n  var Level = {\n    INTRO: 0,\n    MOVE_LEFT: 1,\n    MOVE_RIGHT: 2,\n    LEVITATE: 3,\n    HIT_THE_MARK: 4\n  };\n\n  /**\n   * Порядок прохождения уровней.\n   * @type {Array.<Level>}\n   */\n  var LevelSequence = [\n    Level.INTRO\n  ];\n\n  /**\n   * Начальный уровень.\n   * @type {Level}\n   */\n  var INITIAL_LEVEL = LevelSequence[0];\n\n  /**\n   * Допустимые виды объектов на карте.\n   * @enum {number}\n   */\n  var ObjectType = {\n    ME: 0,\n    FIREBALL: 1\n  };\n\n  /**\n   * Допустимые состояния объектов.\n   * @enum {number}\n   */\n  var ObjectState = {\n    OK: 0,\n    DISPOSED: 1\n  };\n\n  /**\n   * Коды направлений.\n   * @enum {number}\n   */\n  var Direction = {\n    NULL: 0,\n    LEFT: 1,\n    RIGHT: 2,\n    UP: 4,\n    DOWN: 8\n  };\n\n  /**\n   * Правила перерисовки объектов в зависимости от состояния игры.\n   * @type {Object.<ObjectType, function(Object, Object, number): Object>}\n   */\n  var ObjectsBehaviour = {};\n\n  /**\n   * Обновление движения мага. Движение мага зависит от нажатых в данный момент\n   * стрелок. Маг может двигаться одновременно по горизонтали и по вертикали.\n   * На движение мага влияет его пересечение с препятствиями.\n   * @param {Object} object\n   * @param {Object} state\n   * @param {number} timeframe\n   */\n  ObjectsBehaviour[ObjectType.ME] = function(object, state, timeframe) {\n    // Пока зажата стрелка вверх, маг сначала поднимается, а потом левитирует\n    // в воздухе на определенной высоте.\n    // NB! Сложность заключается в том, что поведение описано в координатах\n    // канваса, а не координатах, относительно нижней границы игры.\n    if (state.keysPressed.UP && object.y > 0) {\n      object.direction = object.direction & ~Direction.DOWN;\n      object.direction = object.direction | Direction.UP;\n      object.y -= object.speed * timeframe * 2;\n\n      if (object.y < 0) {\n        object.y = 0;\n      }\n    }\n\n    // Если стрелка вверх не зажата, а маг находится в воздухе, он плавно\n    // опускается на землю.\n    if (!state.keysPressed.UP) {\n      if (object.y < HEIGHT - object.height) {\n        object.direction = object.direction & ~Direction.UP;\n        object.direction = object.direction | Direction.DOWN;\n        object.y += object.speed * timeframe / 3;\n      } else {\n        object.Direction = object.direction & ~Direction.DOWN;\n      }\n    }\n\n    // Если зажата стрелка влево, маг перемещается влево.\n    if (state.keysPressed.LEFT) {\n      object.direction = object.direction & ~Direction.RIGHT;\n      object.direction = object.direction | Direction.LEFT;\n      object.x -= object.speed * timeframe;\n    }\n\n    // Если зажата стрелка вправо, маг перемещается вправо.\n    if (state.keysPressed.RIGHT) {\n      object.direction = object.direction & ~Direction.LEFT;\n      object.direction = object.direction | Direction.RIGHT;\n      object.x += object.speed * timeframe;\n    }\n\n    // Ограничения по перемещению по полю. Маг не может выйти за пределы поля.\n    if (object.y < 0) {\n      object.y = 0;\n      object.Direction = object.direction & ~Direction.DOWN;\n      object.Direction = object.direction & ~Direction.UP;\n    }\n\n    if (object.y > HEIGHT - object.height) {\n      object.y = HEIGHT - object.height;\n      object.Direction = object.direction & ~Direction.DOWN;\n      object.Direction = object.direction & ~Direction.UP;\n    }\n\n    if (object.x < 0) {\n      object.x = 0;\n    }\n\n    if (object.x > WIDTH - object.width) {\n      object.x = WIDTH - object.width;\n    }\n  };\n\n  /**\n   * Обновление движения файрбола. Файрбол выпускается в определенном направлении\n   * и после этого неуправляемо движется по прямой в заданном направлении. Если\n   * он пролетает весь экран насквозь, он исчезает.\n   * @param {Object} object\n   * @param {Object} state\n   * @param {number} timeframe\n   */\n  ObjectsBehaviour[ObjectType.FIREBALL] = function(object, state, timeframe) {\n    if (object.direction & Direction.LEFT) {\n      object.x -= object.speed * timeframe;\n    }\n\n    if (object.direction & Direction.RIGHT) {\n      object.x += object.speed * timeframe;\n    }\n\n    if (object.x < 0 || object.x > WIDTH) {\n      object.state = ObjectState.DISPOSED;\n    }\n  };\n\n  /**\n   * ID возможных ответов функций, проверяющих успех прохождения уровня.\n   * CONTINUE говорит о том, что раунд не закончен и игру нужно продолжать,\n   * WIN о том, что раунд выигран, FAIL — о поражении. PAUSE о том, что игру\n   * нужно прервать.\n   * @enum {number}\n   */\n  var Verdict = {\n    CONTINUE: 0,\n    WIN: 1,\n    FAIL: 2,\n    PAUSE: 3,\n    INTRO: 4\n  };\n\n  /**\n   * Правила завершения уровня. Ключами служат ID уровней, значениями функции\n   * принимающие на вход состояние уровня и возвращающие true, если раунд\n   * можно завершать или false если нет.\n   * @type {Object.<Level, function(Object):boolean>}\n   */\n  var LevelsRules = {};\n\n  /**\n   * Уровень считается пройденным, если был выпущен файлболл и он улетел\n   * за экран.\n   * @param {Object} state\n   * @return {Verdict}\n   */\n  LevelsRules[Level.INTRO] = function(state) {\n    var fireballs = state.garbage.filter(function(object) {\n      return object.type === ObjectType.FIREBALL;\n    });\n\n    return fireballs.length ? Verdict.WIN : Verdict.CONTINUE;\n  };\n\n  /**\n   * Начальные условия для уровней.\n   * @enum {Object.<Level, function>}\n   */\n  var LevelsInitialize = {};\n\n  /**\n   * Первый уровень.\n   * @param {Object} state\n   * @return {Object}\n   */\n  LevelsInitialize[Level.INTRO] = function(state) {\n    state.objects.push(\n      // Установка персонажа в начальное положение. Он стоит в крайнем левом\n      // углу экрана, глядя вправо. Скорость перемещения персонажа на этом\n      // уровне равна 2px за кадр.\n      {\n        direction: Direction.RIGHT,\n        height: 84,\n        speed: 2,\n        sprite: 'img/wizard.gif',\n        spriteReversed: 'img/wizard-reversed.gif',\n        state: ObjectState.OK,\n        type: ObjectType.ME,\n        width: 61,\n        x: WIDTH / 3,\n        y: HEIGHT - 100\n      }\n    );\n\n    return state;\n  };\n\n  /**\n   * Конструктор объекта Game. Создает canvas, добавляет обработчики событий\n   * и показывает приветственный экран.\n   * @param {Element} container\n   * @constructor\n   */\n  var Game = function(container) {\n    this.container = container;\n    this.canvas = document.createElement('canvas');\n    this.canvas.width = container.clientWidth;\n    this.canvas.height = container.clientHeight;\n    this.container.appendChild(this.canvas);\n\n    this.ctx = this.canvas.getContext('2d');\n\n    this._onKeyDown = this._onKeyDown.bind(this);\n    this._onKeyUp = this._onKeyUp.bind(this);\n    this._pauseListener = this._pauseListener.bind(this);\n\n    this.setDeactivated(false);\n  };\n\n  Game.prototype = {\n    /**\n     * Текущий уровень игры.\n     * @type {Level}\n     */\n    level: INITIAL_LEVEL,\n\n    /** @param {boolean} deactivated */\n    setDeactivated: function(deactivated) {\n      if (this._deactivated === deactivated) {\n        return;\n      }\n\n      this._deactivated = deactivated;\n\n      if (deactivated) {\n        this._removeGameListeners();\n      } else {\n        this._initializeGameListeners();\n      }\n    },\n\n    /**\n     * Состояние игры. Описывает местоположение всех объектов на игровой карте\n     * и время проведенное на уровне и в игре.\n     * @return {Object}\n     */\n    getInitialState: function() {\n      return {\n        // Статус игры. Если CONTINUE, то игра продолжается.\n        currentStatus: Verdict.CONTINUE,\n\n        // Объекты, удаленные на последнем кадре.\n        garbage: [],\n\n        // Время с момента отрисовки предыдущего кадра.\n        lastUpdated: null,\n\n        // Состояние нажатых клавиш.\n        keysPressed: {\n          ESC: false,\n          LEFT: false,\n          RIGHT: false,\n          SPACE: false,\n          UP: false\n        },\n\n        // Время начала прохождения уровня.\n        levelStartTime: null,\n\n        // Все объекты на карте.\n        objects: [],\n\n        // Время начала прохождения игры.\n        startTime: null\n      };\n    },\n\n    /**\n     * Начальные проверки и запуск текущего уровня.\n     * @param {Level=} level\n     * @param {boolean=} restart\n     */\n    initializeLevelAndStart: function(level, restart) {\n      level = typeof level === 'undefined' ? this.level : level;\n      restart = typeof restart === 'undefined' ? true : restart;\n\n      if (restart || !this.state) {\n        // При перезапуске уровня, происходит полная перезапись состояния\n        // игры из изначального состояния.\n        this.state = this.getInitialState();\n        this.state = LevelsInitialize[this.level](this.state);\n      } else {\n        // При продолжении уровня состояние сохраняется, кроме записи о том,\n        // что состояние уровня изменилось с паузы на продолжение игры.\n        this.state.currentStatus = Verdict.CONTINUE;\n      }\n\n      // Запись времени начала игры и времени начала уровня.\n      this.state.levelStartTime = Date.now();\n      if (!this.state.startTime) {\n        this.state.startTime = this.state.levelStartTime;\n      }\n\n      this._preloadImagesForLevel(function() {\n        // Предварительная отрисовка игрового экрана.\n        this.render();\n\n        // Установка обработчиков событий.\n        this._initializeGameListeners();\n\n        // Запуск игрового цикла.\n        this.update();\n      }.bind(this));\n    },\n\n    /**\n     * Временная остановка игры.\n     * @param {Verdict=} verdict\n     */\n    pauseLevel: function(verdict) {\n      if (verdict) {\n        this.state.currentStatus = verdict;\n      }\n\n      this.state.keysPressed.ESC = false;\n      this.state.lastUpdated = null;\n\n      this._removeGameListeners();\n      window.addEventListener('keydown', this._pauseListener);\n\n      this._drawPauseScreen();\n    },\n\n    /**\n     * Обработчик событий клавиатуры во время паузы.\n     * @param {KeyboardsEvent} evt\n     * @private\n     * @private\n     */\n    _pauseListener: function(evt) {\n      if (evt.keyCode === 32 && !this._deactivated) {\n        evt.preventDefault();\n        var needToRestartTheGame = this.state.currentStatus === Verdict.WIN ||\n          this.state.currentStatus === Verdict.FAIL;\n        this.initializeLevelAndStart(this.level, needToRestartTheGame);\n\n        window.removeEventListener('keydown', this._pauseListener);\n      }\n    },\n\n    /**\n     * Отрисовка экрана паузы.\n     */\n    _drawPauseScreen: function() {\n\n      /**\n       * блок с переменными\n       */\n      var messagesList = {\n        'win': 'Ты победил! Но запомни: дискретность индуктивно дискредитирует дедуктивный метод',\n        'fail': 'Ты проиграл! Народная мудрость в утешение: \"Реальность осмысленно транспонирует субъективный катарсис\"',\n        'pause': 'Пока игра поставлена на паузу, обратимся к цитатам великих: \"Структурализм, по определению, понимает под собой знак\"',\n        'intro': 'Я умею перемещаться и летать по нажатию на стрелки. А если нажать Shift, я выстрелю файерволом! И помни: предмет деятельности амбивалентно творит сенсибельный гравитационный парадокс'\n      };\n\n      var message;\n      switch (this.state.currentStatus) {\n        case Verdict.WIN:\n          message = messagesList.win;\n          break;\n\n        case Verdict.FAIL:\n          message = messagesList.fail;\n          break;\n\n        case Verdict.PAUSE:\n          message = messagesList.pause;\n          break;\n\n        case Verdict.INTRO:\n          message = messagesList.intro;\n          break;\n      }\n\n      this._drawMessage(message);\n\n    },\n    /**\n     * Отрисовка диалогового окна с сообщением\n     * @param {String[]} message текст собщения\n     */\n    _drawMessage: function(message) {\n\n      /**\n       * параметры шрифта для корректного вычисления константы SYMBOL_WIDTH\n       */\n      this.ctx.font = '16px PT Mono, serif';\n\n      /**\n       * блок с переменными\n       */\n      var self = this;\n\n      var rectWidth = 300;\n      var rectX = 300; // X-координата начала\n      var rectY = 50; // Y-координата начала\n\n      var padding = 10; // смещение по X-и Y- координатам\n\n      var fontSize = 16;\n      var lineHeight = fontSize * 1.2;\n\n      // вычисляем ширину символа\n      var SYMBOL_WIDTH = self.ctx.measureText('M').width;\n\n      // вычисляем ширину сообщения с учетом отступов\n      var messageLength = (rectWidth - (padding * 2)) / SYMBOL_WIDTH;\n\n      var transformStringIntoArray = splitText(message, messageLength);\n\n      var messageHeight = transformStringIntoArray.length * lineHeight;\n\n      /**\n       * Функция отрисовывания диалогового окна:\n       * @param {Number} x координата левого верхнего угла по оси x\n       * @param {Number} y координата левого верхнего угла по оси y\n       * @param {Number} width ширина прямоугольника\n       * @param {Number} height высота прямоугольника\n       */\n      function createRect(x, y, width, height) {\n        // 1. тень от прямоугольника\n        self.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';\n        self.ctx.fillRect(x + padding, y + padding, width, height);\n\n        // 2. прямоугольник: обводка\n        self.ctx.strokeStyle = '#000';\n        self.ctx.lineWidth = 5;\n        self.ctx.strokeRect(x, y, width, height);\n\n        // 3. прямоугольник: заливка\n        self.ctx.fillStyle = '#fff';\n        self.ctx.fillRect(x, y, width, height);\n      }\n\n      createRect(rectX, rectY, rectWidth, messageHeight + padding * 2);\n\n      /**\n       * Функция вывода сообщения на холст.\n       * @param {String} element Строка, которая передается ctx-объекту fillText\n       */\n      function createMessage(element) {\n        // параметры шрифта\n        self.ctx.textAlign = 'center';\n        self.ctx.textBaseline = 'top';\n        self.ctx.fillStyle = '#000';\n\n        self.ctx.fillText(element, rectX + rectWidth / 2, rectY + padding );\n        rectY += lineHeight;\n      }\n\n      /**\n       * Функция создания из строки массива заданной ширины:\n       * @param {String} str строка, которую необходимо преобразовать в массив\n       * @param {Number} len число, ограничивающее длину эл-та в массиве\n       * @returns {Array}\n       */\n      function splitText(str, len) {\n        var arr = [];\n\n        str = str.split(' ');\n\n        var result = str.reduce(function(sum, el) {\n\n          if (( sum.length + el.length ) <= len) {\n            return sum + ' ' + el;\n          }\n\n          arr.push(sum);\n          sum = el;\n\n          return sum;\n\n        });\n\n        arr.push(result);\n\n        return arr;\n      }\n\n      // для каждой строки, записанной в виде строкового значения в объект messagesList,\n      // вызываем функцию splitText, после чего на каждой приведенной к массиву строке\n      // вызываем метод forEach, который в свою очередь возвращает callback-функцию,\n      // генерирующее сообщение на холсте\n      transformStringIntoArray.forEach(createMessage);\n    },\n\n    /**\n     * Предзагрузка необходимых изображений для уровня.\n     * @param {function} callback\n     * @private\n     */\n    _preloadImagesForLevel: function(callback) {\n      if (typeof this._imagesArePreloaded === 'undefined') {\n        this._imagesArePreloaded = [];\n      }\n\n      if (this._imagesArePreloaded[this.level]) {\n        callback();\n        return;\n      }\n\n      var levelImages = [];\n      this.state.objects.forEach(function(object) {\n        levelImages.push(object.sprite);\n\n        if (object.spriteReversed) {\n          levelImages.push(object.spriteReversed);\n        }\n      });\n\n      var i = levelImages.length;\n      var imagesToGo = levelImages.length;\n\n      while (i-- > 0) {\n        var image = new Image();\n        image.src = levelImages[i];\n        image.onload = function() {\n          if (--imagesToGo === 0) {\n            this._imagesArePreloaded[this.level] = true;\n            callback();\n          }\n        }.bind(this);\n      }\n    },\n\n    /**\n     * Обновление статуса объектов на экране. Добавляет объекты, которые должны\n     * появиться, выполняет проверку поведения всех объектов и удаляет те, которые\n     * должны исчезнуть.\n     * @param {number} delta Время, прошеднее с отрисовки прошлого кадра.\n     */\n    updateObjects: function(delta) {\n      // Персонаж.\n      var me = this.state.objects.filter(function(object) {\n        return object.type === ObjectType.ME;\n      })[0];\n\n      // Добавляет на карту файрбол по нажатию на Shift.\n      if (this.state.keysPressed.SHIFT) {\n        this.state.objects.push({\n          direction: me.direction,\n          height: 24,\n          speed: 5,\n          sprite: 'img/fireball.gif',\n          type: ObjectType.FIREBALL,\n          width: 24,\n          x: me.direction & Direction.RIGHT ? me.x + me.width : me.x - 24,\n          y: me.y + me.height / 2\n        });\n\n        this.state.keysPressed.SHIFT = false;\n      }\n\n      this.state.garbage = [];\n\n      // Убирает в garbage не используемые на карте объекты.\n      var remainingObjects = this.state.objects.filter(function(object) {\n        ObjectsBehaviour[object.type](object, this.state, delta);\n\n        if (object.state === ObjectState.DISPOSED) {\n          this.state.garbage.push(object);\n          return false;\n        }\n\n        return true;\n      }, this);\n\n      this.state.objects = remainingObjects;\n    },\n\n    /**\n     * Проверка статуса текущего уровня.\n     */\n    checkStatus: function() {\n      // Нет нужны запускать проверку, нужно ли останавливать уровень, если\n      // заранее известно, что да.\n      if (this.state.currentStatus !== Verdict.CONTINUE) {\n        return;\n      }\n\n      if (!this.commonRules) {\n        /**\n         * Проверки, не зависящие от уровня, но влияющие на его состояние.\n         * @type {Array.<functions(Object):Verdict>}\n         */\n        this.commonRules = [\n          /**\n           * Если персонаж мертв, игра прекращается.\n           * @param {Object} state\n           * @return {Verdict}\n           */\n          function checkDeath(state) {\n            var me = state.objects.filter(function(object) {\n              return object.type === ObjectType.ME;\n            })[0];\n\n            return me.state === ObjectState.DISPOSED ?\n              Verdict.FAIL :\n              Verdict.CONTINUE;\n          },\n\n          /**\n           * Если нажата клавиша Esc игра ставится на паузу.\n           * @param {Object} state\n           * @return {Verdict}\n           */\n          function checkKeys(state) {\n            return state.keysPressed.ESC ? Verdict.PAUSE : Verdict.CONTINUE;\n          },\n\n          /**\n           * Игра прекращается если игрок продолжает играть в нее два часа подряд.\n           * @param {Object} state\n           * @return {Verdict}\n           */\n          function checkTime(state) {\n            return Date.now() - state.startTime > 3 * 60 * 1000 ?\n              Verdict.FAIL :\n              Verdict.CONTINUE;\n          }\n        ];\n      }\n\n      // Проверка всех правил влияющих на уровень. Запускаем цикл проверок\n      // по всем универсальным проверкам и проверкам конкретного уровня.\n      // Цикл продолжается до тех пор, пока какая-либо из проверок не вернет\n      // любое другое состояние кроме CONTINUE или пока не пройдут все\n      // проверки. После этого состояние сохраняется.\n      var allChecks = this.commonRules.concat(LevelsRules[this.level]);\n      var currentCheck = Verdict.CONTINUE;\n      var currentRule;\n\n      while (currentCheck === Verdict.CONTINUE && allChecks.length) {\n        currentRule = allChecks.shift();\n        currentCheck = currentRule(this.state);\n      }\n\n      this.state.currentStatus = currentCheck;\n    },\n\n    /**\n     * Принудительная установка состояния игры. Используется для изменения\n     * состояния игры от внешних условий, например, когда необходимо остановить\n     * игру, если она находится вне области видимости и установить вводный\n     * экран.\n     * @param {Verdict} status\n     */\n    setGameStatus: function(status) {\n      if (this.state.currentStatus !== status) {\n        this.state.currentStatus = status;\n      }\n    },\n\n    /**\n     * Отрисовка всех объектов на экране.\n     */\n    render: function() {\n      // Удаление всех отрисованных на странице элементов.\n      this.ctx.clearRect(0, 0, WIDTH, HEIGHT);\n\n      // Выставление всех элементов, оставшихся в this.state.objects согласно\n      // их координатам и направлению.\n      this.state.objects.forEach(function(object) {\n        if (object.sprite) {\n          var image = new Image(object.width, object.height);\n          image.src = (object.spriteReversed && object.direction & Direction.LEFT) ?\n            object.spriteReversed :\n            object.sprite;\n          this.ctx.drawImage(image, object.x, object.y, object.width, object.height);\n        }\n      }, this);\n    },\n\n    /**\n     * Основной игровой цикл. Сначала проверяет состояние всех объектов игры\n     * и обновляет их согласно правилам их поведения, а затем запускает\n     * проверку текущего раунда. Рекурсивно продолжается до тех пор, пока\n     * проверка не вернет состояние FAIL, WIN или PAUSE.\n     */\n    update: function() {\n      if (!this.state.lastUpdated) {\n        this.state.lastUpdated = Date.now();\n      }\n\n      var delta = (Date.now() - this.state.lastUpdated) / 10;\n      this.updateObjects(delta);\n      this.checkStatus();\n\n      switch (this.state.currentStatus) {\n        case Verdict.CONTINUE:\n          this.state.lastUpdated = Date.now();\n          this.render();\n          requestAnimationFrame(function() {\n            this.update();\n          }.bind(this));\n          break;\n\n        case Verdict.WIN:\n        case Verdict.FAIL:\n        case Verdict.PAUSE:\n        case Verdict.INTRO:\n          this.pauseLevel();\n          break;\n      }\n    },\n\n    /**\n     * @param {KeyboardEvent} evt [description]\n     * @private\n     */\n    _onKeyDown: function(evt) {\n      switch (evt.keyCode) {\n        case 37:\n          this.state.keysPressed.LEFT = true;\n          break;\n        case 39:\n          this.state.keysPressed.RIGHT = true;\n          break;\n        case 38:\n          this.state.keysPressed.UP = true;\n          break;\n        case 27:\n          this.state.keysPressed.ESC = true;\n          break;\n      }\n\n      if (evt.shiftKey) {\n        this.state.keysPressed.SHIFT = true;\n      }\n    },\n\n    /**\n     * @param {KeyboardEvent} evt [description]\n     * @private\n     */\n    _onKeyUp: function(evt) {\n      switch (evt.keyCode) {\n        case 37:\n          this.state.keysPressed.LEFT = false;\n          break;\n        case 39:\n          this.state.keysPressed.RIGHT = false;\n          break;\n        case 38:\n          this.state.keysPressed.UP = false;\n          break;\n        case 27:\n          this.state.keysPressed.ESC = false;\n          break;\n      }\n\n      if (evt.shiftKey) {\n        this.state.keysPressed.SHIFT = false;\n      }\n    },\n\n    /** @private */\n    _initializeGameListeners: function() {\n      window.addEventListener('keydown', this._onKeyDown);\n      window.addEventListener('keyup', this._onKeyUp);\n    },\n\n    /** @private */\n    _removeGameListeners: function() {\n      window.removeEventListener('keydown', this._onKeyDown);\n      window.removeEventListener('keyup', this._onKeyUp);\n    }\n  };\n\n  Game.Verdict = Verdict;\n\n  return Game;\n})();\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/game.js\n ** module id = 4\n ** module chunks = 0\n **/"],"sourceRoot":""}